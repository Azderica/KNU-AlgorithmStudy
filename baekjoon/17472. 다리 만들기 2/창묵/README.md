# 다리만들기

# 풀이방법

다리만들기 문제를 풀때, BFS와 크루스칼 알고리즘을 이용해 최소신장트리를 이용하여 문제를 풀었다.

1. map에 있는 섬을 하나로 맵핑하기위해 bfs를 이용하여 각 섬들을 랜더링하였다. 섬마다 숫자 1,2,3,4 를 부여하였다.
2. 랜더링하면서 각 섬의 한칸씩 한칸씩(index)를 큐에 저장하여서, bfs를 실행하여, 다른 섬까지 다리를 놓을 수 있는지 판단하였고, 다리를 놓을 수 있게 된다면
   또 다른 Q에 (시작섬 번호, 도착점번호, 다리길이 ) 이렇게 Node화 시켜서 큐에 저장을 시켰다.

=> 여기까지는 잘 진행했으나 또 문제를 잘 못 읽어서 나는 처음에 모든 섬마다 다리를 다 놓아야하는 줄 알았고, 다리를 놓았을 때 최소한의 길이를 출력하는 건줄 알았다.
그래서 2번에서 만든 Q를 하나씩 poll하면서 min_distance[시작섬][끝섬]에 최소값을 저장시키는 식으로 했는데 그게 아니였다..
알고보니 그냥 각 섬이 다 연결할 수 있도록 하는 경우의 최소 다리길이를 구하는 것이었다.. 

그래프관련해서 다 검색해봤는데 최소신장트리를 이용하면 이 문제를 해결 할 수 있을 것 같았다. 이 최소신장 트리를 만들려면 크루스칼 알고리즘을 사용해야 했는데
이 문제 덕분에 크루스칼 알고리즘을 공부할 수 있었다.

3. min_distance[][]에 저장 되어있는 값은 sort이 되어 있지 않기에 크루스칼을 사용하려면 sort한 값을 이용해야해서, 하나의 list를 만들어 sorting 시켰다.

-> 문제를 다 풀고 느낀 거지만 애초에 2번에서 만든 Q를 우선순위 큐로 설정하여서 만들었으면 min_distance[][] 배열도 만들필요없을 뿐더러 따로 List를 만들 필요도 없었다...

4. 크루스칼알고리즘에서의 find / union을 거쳐서 union이 될때마다 result에 값을 더했다.

5. 각 모든 섬이 연결되어야 한다고 했으므로, 트리의 root가 한개 일 때가 아니면 -1을 출력, root가 1개라면 result를 메인에서 출력하게 하였다.

# 느낀점

크루스칼 알고리즘, 최소신장트리, 우선순위 큐의 중요성을 깨달았다.